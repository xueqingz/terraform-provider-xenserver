package xenserver

import (
	"context"
	"errors"
	"sort"

	"xenapi"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type vifResourceModel struct {
	Network     types.String `tfsdk:"network_uuid"`
	VIF         types.String `tfsdk:"vif_ref"`
	MTU         types.Int64  `tfsdk:"mtu"`
	MAC         types.String `tfsdk:"mac"`
	OtherConfig types.Map    `tfsdk:"other_config"`
}

var vifResourceModelAttrTypes = map[string]attr.Type{
	"network_uuid": types.StringType,
	"vif_ref":      types.StringType,
	"mtu":          types.Int64Type,
	"mac":          types.StringType,
	"other_config": types.MapType{ElemType: types.StringType},
}

func VIFSchema() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"network_uuid": schema.StringAttribute{
			MarkdownDescription: "Network UUID to attach to VIF",
			Required:            true,
		},
		"vif_ref": schema.StringAttribute{
			MarkdownDescription: "VIF Reference",
			Computed:            true,
		},
		"mtu": schema.Int64Attribute{
			MarkdownDescription: "MTU in octets, default: 1500, range limit to [1500, 9216]",
			Optional:            true,
			Computed:            true,
			Default:             int64default.StaticInt64(1500),
		},
		"mac": schema.StringAttribute{
			MarkdownDescription: "MAC address of the VIF, if not provided, XenServer will generate a random MAC address.",
			Optional:            true,
			Computed:            true,
		},
		"other_config": schema.MapAttribute{
			MarkdownDescription: "The additional configuration, default to be {}",
			Optional:            true,
			Computed:            true,
			Default:             mapdefault.StaticValue(types.MapValueMust(types.StringType, map[string]attr.Value{})),
			ElementType:         types.StringType,
		},
	}
}

func createVIF(ctx context.Context, vif vifResourceModel, vmRef xenapi.VMRef, session *xenapi.Session) (xenapi.VIFRef, error) {
	var vifRef xenapi.VIFRef
	networkRef, err := xenapi.Network.GetByUUID(session, vif.Network.ValueString())
	if err != nil {
		return vifRef, errors.New(err.Error())
	}

	userDevices, err := xenapi.VM.GetAllowedVIFDevices(session, vmRef)
	if err != nil {
		return vifRef, errors.New(err.Error())
	}

	if len(userDevices) == 0 {
		return vifRef, errors.New("No available vif devices to attach to vm " + string(vmRef))
	}

	if vif.MTU.ValueInt64() < 1500 || vif.MTU.ValueInt64() > 9216 {
		return vifRef, errors.New("MTU value should be in the range [1500, 9216]")
	}

	if !vif.MAC.IsNull() && !vif.MAC.IsUnknown() && vif.MAC.ValueString() == "" {
		return vifRef, errors.New("MAC address should not be empty")
	}

	if vif.MAC.IsNull() {
		vif.MAC = types.StringValue("")
	}

	otherConfig := make(map[string]string)
	diags := vif.OtherConfig.ElementsAs(ctx, &otherConfig, false)
	if diags.HasError() {
		return vifRef, errors.New("unable to get VIF other config")
	}

	vifRecord := xenapi.VIFRecord{
		VM:               vmRef,
		Network:          networkRef,
		MAC:              vif.MAC.ValueString(),
		MTU:              int(vif.MTU.ValueInt64()),
		Device:           userDevices[0],
		OtherConfig:      otherConfig,
		LockingMode:      xenapi.VifLockingModeNetworkDefault,
		MACAutogenerated: vif.MAC.ValueString() == "",
	}

	vifRef, err = xenapi.VIF.Create(session, vifRecord)
	if err != nil {
		return vifRef, errors.New(err.Error())
	}

	vmPowerState, err := xenapi.VM.GetPowerState(session, vmRef)
	if err != nil {
		return vifRef, errors.New(err.Error())
	}

	if vmPowerState == xenapi.VMPowerStateRunning {
		err = xenapi.VIF.Plug(session, vifRef)
		if err != nil {
			return vifRef, errors.New(err.Error())
		}
	}

	return vifRef, nil
}

func createVIFs(ctx context.Context, data vmResourceModel, vmRef xenapi.VMRef, session *xenapi.Session) ([]xenapi.VIFRef, error) {
	elements := make([]vifResourceModel, 0, len(data.NetworkInterface.Elements()))
	diags := data.NetworkInterface.ElementsAs(ctx, &elements, false)
	if diags.HasError() {
		return nil, errors.New("unable to get Network Interface elements")
	}

	var vifRefs []xenapi.VIFRef
	for _, vif := range elements {
		vifRef, err := createVIF(ctx, vif, vmRef, session)
		if err != nil {
			return nil, err
		}
		vifRefs = append(vifRefs, vifRef)
	}
	return vifRefs, nil
}

// sortNetworkInterface sorts the Network Interface list based on Network UUID, this is required to compare the VIFs in plan and state
func sortNetworkInterface(ctx context.Context, planNetworkInterface basetypes.ListValue) (basetypes.ListValue, error) {
	// func sortNetworkInterface(ctx context.Context, planNetworkInterface basetypes.ListValue, stateNetworkInterface basetypes.ListValue) (basetypes.ListValue, error) {
	var listValue basetypes.ListValue
	planVIFList := make([]vifResourceModel, 0, len(planNetworkInterface.Elements()))
	diags := planNetworkInterface.ElementsAs(ctx, &planVIFList, false)
	if diags.HasError() {
		return listValue, errors.New("unable to get VIF list from plan")
	}

	// stateVIFList := make([]vifResourceModel, 0, len(stateNetworkInterface.Elements()))
	// diags = stateNetworkInterface.ElementsAs(ctx, &stateVIFList, false)
	// if diags.HasError() {
	// 	return listValue, errors.New("unable to get VIF list from state")
	// }

	sort.Slice(planVIFList, func(i, j int) bool {
		return planVIFList[i].Network.ValueString() < planVIFList[j].Network.ValueString()
	})

	// for _, planVIF := range planVIFList {
	// 	//If it is empty, set it to empty string to avoid comparing MAC address
	// 	if planVIF.MAC.ValueString() == "" {
	// 		// find the corresponding VIF in stateVIFList by uuid
	// 		for _, stateVIF := range stateVIFList {
	// 			if stateVIF.Network.ValueString() == planVIF.Network.ValueString() {
	// 				planVIF.MAC = types.StringValue(stateVIF.MAC.ValueString())
	// 			}
	// 		}
	// 	}
	// }

	listValue, diags = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: vifResourceModelAttrTypes}, planVIFList)
	if diags.HasError() {
		return listValue, errors.New("unable to get VIF list value")
	}

	return listValue, nil
}
