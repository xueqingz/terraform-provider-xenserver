package xenserver

import (
	"context"
	"errors"

	"xenapi"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

type vifResourceModel struct {
	Network types.String `tfsdk:"network_uuid"`
	VIF     types.String `tfsdk:"vif_ref"`
	MTU     types.Int64  `tfsdk:"mtu"`
	// MAC         types.String `tfsdk:"mac"`
	// OtherConfig types.Map    `tfsdk:"other_config"`
}

var vifResourceModelAttrTypes = map[string]attr.Type{
	"network_uuid": types.StringType,
	"vif_ref":      types.StringType,
	"mtu":          types.Int64Type,
	// "mac":          types.StringType,
	// "other_config": types.MapType{ElemType: types.StringType},
}

func VIFSchema() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"network_uuid": schema.StringAttribute{
			MarkdownDescription: "Network UUID to attach to VIF",
			Required:            true,
		},
		"vif_ref": schema.StringAttribute{
			MarkdownDescription: "VIF Reference",
			Computed:            true,
		},
		"mtu": schema.Int64Attribute{
			MarkdownDescription: "MTU in octets, default: 1500",
			Optional:            true,
			Computed:            true,
			Default:             int64default.StaticInt64(1500),
		},
		// "mac": schema.StringAttribute{
		// 	MarkdownDescription: "MAC address of the VIF, if not provided, XenServer will generate a random MAC address.",
		// 	// Optional:            true,
		// 	// Computed:            true,
		// 	Required: true,
		// },
		// "other_config": schema.MapAttribute{
		// 	MarkdownDescription: "The additional configuration, default to be {}",
		// 	ElementType:         types.StringType,
		// 	Required:            true,
		// 	// Optional:            true,
		// 	// Computed:            true,
		// 	// Default:             mapdefault.StaticValue(types.MapValueMust(types.StringType, map[string]attr.Value{})),
		// },
	}
}

func createVIF(ctx context.Context, vif vifResourceModel, vmRef xenapi.VMRef, session *xenapi.Session) (xenapi.VIFRef, error) {
	var vifRef xenapi.VIFRef
	networkRef, err := xenapi.Network.GetByUUID(session, vif.Network.ValueString())
	if err != nil {
		return vifRef, errors.New(err.Error())
	}

	userDevices, err := xenapi.VM.GetAllowedVIFDevices(session, vmRef)
	if err != nil {
		return vifRef, errors.New(err.Error())
	}

	if len(userDevices) == 0 {
		return vifRef, errors.New("No available vif devices to attach to vm " + string(vmRef))
	}

	// if !vif.MAC.IsNull() && !vif.MAC.IsUnknown() && vif.MAC.ValueString() == "" {
	// 	return vifRef, errors.New("MAC address should not be empty")
	// }

	// if vif.MAC.IsNull() || vif.MAC.IsUnknown() {
	// 	vif.MAC = types.StringValue("")
	// }

	// otherConfig := make(map[string]string)
	// diags := vif.OtherConfig.ElementsAs(ctx, &otherConfig, false)
	// if diags.HasError() {
	// 	return vifRef, errors.New("unable to get VIF other config")
	// }

	// vifRecord := xenapi.VIFRecord{
	// 	VM:               vmRef,
	// 	Network:          networkRef,
	// 	MAC:              vif.MAC.ValueString(),
	// 	Device:           userDevices[0],
	// 	OtherConfig:      otherConfig,
	// 	LockingMode:      xenapi.VifLockingModeNetworkDefault,
	// 	MACAutogenerated: vif.MAC.ValueString() == "",
	// }
	vifRecord := xenapi.VIFRecord{
		VM:          vmRef,
		Network:     networkRef,
		MAC:         "11:22:33:44:55:66",
		MTU:         int(vif.MTU.ValueInt64()),
		Device:      userDevices[0],
		LockingMode: xenapi.VifLockingModeNetworkDefault,
	}

	vifRef, err = xenapi.VIF.Create(session, vifRecord)
	if err != nil {
		return vifRef, errors.New(err.Error())
	}

	tflog.Debug(ctx, "+++++++++++++VIF created with ref: "+string(vifRef))

	vmPowerState, err := xenapi.VM.GetPowerState(session, vmRef)
	if err != nil {
		return vifRef, errors.New(err.Error())
	}

	if vmPowerState == xenapi.VMPowerStateRunning {
		err = xenapi.VIF.Plug(session, vifRef)
		if err != nil {
			return vifRef, errors.New(err.Error())
		}
	}

	return vifRef, nil
}

func createVIFs(ctx context.Context, data vmResourceModel, vmRef xenapi.VMRef, session *xenapi.Session) ([]xenapi.VIFRef, error) {
	elements := make([]vifResourceModel, 0, len(data.NetworkInterface.Elements()))
	diags := data.NetworkInterface.ElementsAs(ctx, &elements, false)
	if diags.HasError() {
		return nil, errors.New("unable to get Network Interface elements")
	}

	var vifRefs []xenapi.VIFRef
	for _, vif := range elements {
		vifRef, err := createVIF(ctx, vif, vmRef, session)
		if err != nil {
			return nil, err
		}
		vifRefs = append(vifRefs, vifRef)
	}
	return vifRefs, nil
}

// sortNetworkInterface sorts the Network Interface list based on Network UUID, this is required to compare the VIFs in plan and state
// func sortNetworkInterface(ctx context.Context, planNetworkInterface basetypes.ListValue) (basetypes.ListValue, error) {
// 	// func sortNetworkInterface(ctx context.Context, planNetworkInterface basetypes.ListValue, stateNetworkInterface basetypes.ListValue) (basetypes.ListValue, error) {
// 	var listValue basetypes.ListValue
// 	planVIFList := make([]vifResourceModel, 0, len(planNetworkInterface.Elements()))
// 	diags := planNetworkInterface.ElementsAs(ctx, &planVIFList, false)
// 	if diags.HasError() {
// 		return listValue, errors.New("unable to get VIF list from plan")
// 	}

// 	// stateVIFList := make([]vifResourceModel, 0, len(stateNetworkInterface.Elements()))
// 	// diags = stateNetworkInterface.ElementsAs(ctx, &stateVIFList, false)
// 	// if diags.HasError() {
// 	// 	return listValue, errors.New("unable to get VIF list from state")
// 	// }

// 	sort.Slice(planVIFList, func(i, j int) bool {
// 		return planVIFList[i].Network.ValueString() < planVIFList[j].Network.ValueString()
// 	})

// 	// for _, planVIF := range planVIFList {
// 	// 	//If it is empty, set it to empty string to avoid comparing MAC address
// 	// 	if planVIF.MAC.ValueString() == "" {
// 	// 		// find the corresponding VIF in stateVIFList by uuid
// 	// 		for _, stateVIF := range stateVIFList {
// 	// 			if stateVIF.Network.ValueString() == planVIF.Network.ValueString() {
// 	// 				planVIF.MAC = types.StringValue(stateVIF.MAC.ValueString())
// 	// 			}
// 	// 		}
// 	// 	}
// 	// }

// 	listValue, diags = types.ListValueFrom(ctx, types.ObjectType{AttrTypes: vifResourceModelAttrTypes}, planVIFList)
// 	if diags.HasError() {
// 		return listValue, errors.New("unable to get VIF list value")
// 	}

// 	return listValue, nil
// }

// func updateVBDs(ctx context.Context, plan vmResourceModel, state vmResourceModel, vmRef xenapi.VMRef, session *xenapi.Session) error {
// 	// Get VBDs from plan and state
// 	planVBDs := make([]vbdResourceModel, 0, len(state.HardDrive.Elements()))
// 	diags := plan.HardDrive.ElementsAs(ctx, &planVBDs, false)
// 	if diags.HasError() {
// 		return errors.New("unable to get VBDs in plan data")
// 	}

// 	stateVBDs := make([]vbdResourceModel, 0, len(state.HardDrive.Elements()))
// 	diags = state.HardDrive.ElementsAs(ctx, &stateVBDs, false)
// 	if diags.HasError() {
// 		return errors.New("unable to get VBDs in state data")
// 	}

// 	var err error
// 	planVDIsMap := make(map[string]vbdResourceModel)
// 	for _, vbd := range planVBDs {
// 		planVDIsMap[vbd.VDI.ValueString()] = vbd
// 	}

// 	stateVDIsMap := make(map[string]vbdResourceModel)
// 	for _, vbd := range stateVBDs {
// 		stateVDIsMap[vbd.VDI.ValueString()] = vbd
// 	}

// 	// Create VBDs that are in plan but not in state, Update VBDs if already exists and attributes changed
// 	for vdiUUID, planVBD := range planVDIsMap {
// 		stateVBD, ok := stateVDIsMap[vdiUUID]
// 		if !ok {
// 			tflog.Debug(ctx, "---> Create VBD for VDI: "+vdiUUID+" <---")
// 			_, err = createVBD(planVBD, vmRef, session)
// 			if err != nil {
// 				return err
// 			}
// 		} else {
// 			tflog.Debug(ctx, "---> Update VBD "+planVBD.VBD.String()+" for VDI: "+vdiUUID+" <---")
// 			if planVBD.Mode != stateVBD.Mode {
// 				err = xenapi.VBD.SetMode(session, xenapi.VBDRef(planVBD.VBD.ValueString()), xenapi.VbdMode(planVBD.Mode.ValueString()))
// 				if err != nil {
// 					return errors.New(err.Error())
// 				}
// 			}

// 			if planVBD.Bootable != stateVBD.Bootable {
// 				err = xenapi.VBD.SetBootable(session, xenapi.VBDRef(planVBD.VBD.ValueString()), planVBD.Bootable.ValueBool())
// 				if err != nil {
// 					return errors.New(err.Error())
// 				}
// 			}
// 		}
// 	}

// 	// Destroy VBDs that are not in plan
// 	for vdiUUID, stateVBD := range stateVDIsMap {
// 		if _, ok := planVDIsMap[vdiUUID]; !ok {
// 			tflog.Debug(ctx, "---> Destroy VBD:	"+stateVBD.VBD.String())
// 			err = xenapi.VBD.Destroy(session, xenapi.VBDRef(stateVBD.VBD.ValueString()))
// 			if err != nil {
// 				return errors.New(err.Error())
// 			}
// 		}
// 	}

// 	return nil
// }

// updateVIF updates the VIFs in the VM based on the plan and state, the logic is similar to updateVBDs
func updateVIFs(ctx context.Context, plan vmResourceModel, state vmResourceModel, vmRef xenapi.VMRef, session *xenapi.Session) error {
	// Get VIFs from plan and state
	planVIFs := make([]vifResourceModel, 0, len(state.NetworkInterface.Elements()))
	diags := plan.NetworkInterface.ElementsAs(ctx, &planVIFs, false)
	if diags.HasError() {
		return errors.New("unable to get VIFs in plan data")
	}

	stateVIFs := make([]vifResourceModel, 0, len(state.NetworkInterface.Elements()))
	diags = state.NetworkInterface.ElementsAs(ctx, &stateVIFs, false)
	if diags.HasError() {
		return errors.New("unable to get VIFs in state data")
	}

	var err error
	planVIFsMap := make(map[string]vifResourceModel)
	for _, vif := range planVIFs {
		planVIFsMap[vif.Network.ValueString()] = vif
	}

	stateVIFsMap := make(map[string]vifResourceModel)
	for _, vif := range stateVIFs {
		stateVIFsMap[vif.Network.ValueString()] = vif
	}

	// Create VIFs that are in plan but not in state, Update VIFs if already exists and attributes changed
	for networkUUID, planVIF := range planVIFsMap {
		stateVIF, ok := stateVIFsMap[networkUUID]
		if !ok {
			tflog.Debug(ctx, "---> Create VIF for Network: "+networkUUID+" <---")
			_, err = createVIF(ctx, planVIF, vmRef, session)
			if err != nil {
				return err
			}
		} else {
			tflog.Debug(ctx, "---> Update VIF "+stateVIF.Network.String()+" for Network: "+networkUUID+" <---")
			if planVIF.MTU != stateVIF.MTU {
				return errors.New("MTU value should not be changed")
			}

			// if planVIF.MAC != stateVIF.MAC {
			// 	return errors.New("MAC address should not be changed")
			// }

			// if !planVIF.OtherConfig.Equal(stateVIF.OtherConfig) {
			// 	otherConfig := make(map[string]string)
			// 	diags := planVIF.OtherConfig.ElementsAs(ctx, &otherConfig, false)
			// 	if diags.HasError() {
			// 		return errors.New("unable to get VIF other config")
			// 	}

			// 	err = xenapi.VIF.SetOtherConfig(session, xenapi.VIFRef(planVIF.VIF.ValueString()), otherConfig)
			// 	if err != nil {
			// 		return errors.New(err.Error())
			// 	}
			// }
		}
	}

	// Destroy VIFs that are not in plan
	for networkUUID, stateVIF := range stateVIFsMap {
		if _, ok := planVIFsMap[networkUUID]; !ok {
			// tflog.Debug(ctx, "---> Destroy VIF:	"+stateVIF.Network.String())
			tflog.Debug(ctx, "---> Destroy VIF:	"+stateVIF.VIF.String())
			err = xenapi.VIF.Destroy(session, xenapi.VIFRef(stateVIF.VIF.ValueString()))
			if err != nil {
				return errors.New(err.Error())
			}
		}
	}

	return nil
}
